# API 설계와 버전 관리 전략
### API를 설계하거나 운영하면서, 일관성을 유지하고 변경을 관리하기 위해 어떤 전략을 사용했는지 설명해 주세요. (버전 관리, 응답 포맷 설계, 호환성 유지 방식 등을 중심으로)
힌트: 실무에서는 API가 한 번 공개되면 쉽게 바꿀 수 없습니다. 이 질문은 "처음부터 바뀔 수 있음을 고려하고 설계했는가"를 묻는 것입니다. URI 버전 관리, 응답 포맷 고정, Deprecation 정책 같은 구체적인 조치가 있다면 강력한 답변이 됩니다.
<br/> <br/>

### 🎯 API 설계 및 운영 전략 경험
1. **응답 포맷 설계 전략** <br/>
API의 일관성과 클라이언트 개발의 편의성을 높이기 위해 공통 응답 포맷을 설계했습니다. 모든 응답은 status, data, message, error_code 필드를 포함하도록 정의했고, 이를 통해 프론트엔드에서의 처리 로직을 단순화할 수 있었습니다. <br/> 
에러 응답의 경우, HTTP status code 외에도 비즈니스 로직에 따른 내부 에러 코드를 함께 반환하는 구조를 도입했습니다. 예를 들어, 400 Bad Request와 함께 "error_code": "INVALID_INPUT"을 반환하여 클라이언트가 더 구체적으로 문제를 파악할 수 있도록 했습니다. <br/> 
또한 팀 내 개발자들과 협의하여 필드 네이밍 규칙으로 통일했으며, 모든 API에서 이를 일관되게 적용하여 개발과 유지보수가 용이하도록 했습니다.

2. **호환성 및 변경 관리 전략** <br/> 
API 문서는 OpenAPI(Swagger)를 기반으로 자동화하여 운영했습니다. 이로 인해 API 변경사항이 문서에 실시간으로 반영되었고, 프론트엔드 개발자들과의 커뮤니케이션 효율이 크게 향상되었습니다. <br/>
요청 및 응답 데이터에 대해서는 JSON Schema를 기반으로 유효성 검사를 적용했습니다. 이를 통해 예상치 못한 필드 누락이나 타입 오류 등을 사전에 방지하고, API의 신뢰성을 높였습니다.
<br/> <br/>

---

## 🌱 API 설계와 버전 관리 전략

### 🥕 1. API 설계 전략
API 설계 전략은 **클라이언트와 서버 간의 통신을 일관되게 만들고, 유지보수가 용이하며 확장 가능한 API**를 만들기 위한 전반적인 설계 지침이다. 이는 데이터 포맷, URI 구조, 응답 형식, 에러 처리 방식 등 다양한 요소를 포함한다.
주요 설계 전략은 다음과 같다. <br/> 
| 전략                     | 설명 |
|--------------------------|------|
| **공통 응답 포맷 정의** | 모든 API 응답에 공통 구조(`status`, `data`, `message`, `error_code` 등)를 적용해 일관성 확보 |
| **에러 응답 표준화**    | HTTP 상태 코드와 내부 에러 코드를 함께 제공하여 문제 파악 및 처리 용이 |
| **일관된 네이밍 규칙 적용** | `snake_case` 또는 `camelCase` 중 하나를 정해 전체 API에서 일관되게 사용 |
| **RESTful 원칙 준수**    | 자원 중심 URI 설계 및 적절한 HTTP 메서드(`GET`, `POST` 등) 사용 |
| **응답 구조의 안정성 유지** | 기존 응답 구조는 변경 없이 유지하고, 필요한 경우에는 필드를 추가하는 방식으로 확장<br>(backward compatibility 고려) |

### 🥕 2. API 버전 관리 전략
API 버전 관리는 **기존 사용자를 보호하면서 새로운 기능이나 변경 사항을 반영**할 수 있도록 하는 전략이다. API는 한 번 배포되면 쉽게 변경할 수 없기 때문에, 변경을 관리할 수 있는 체계가 필요하다. 주요 버전 관리 전략을 다음과 같다. <br/> 
| 전략                     | 설명 |
|--------------------------|------|
| **URI 기반 버전 관리**   | `/api/v1/`처럼 URL에 버전을 명시하여 직관적으로 관리 |
| **헤더 기반 버전 관리**  | `Accept` 헤더에 버전 정보 포함 → URI는 고정, 유연한 버전 관리 가능 |
| **쿼리 파라미터 방식**    | `/api/resource?version=1` 형태로 간단히 버전을 지정 (일반적으로 권장되지 않음) |
| **Semantic Versioning 도입** | 내부적으로 기능/버그/보안 패치 등을 구분해 `v1.2.0`처럼 상세 버전 관리 |
| **Deprecation 정책 운영** | 구버전 API에 대해 일정 기간 지원 후 폐기, 사전 공지 필수 |

### 🧑🏻‍🌾 3. 변경 관리 및 호환성 유지 전략
| 전략                             | 설명 |
|----------------------------------|------|
| **OpenAPI(Swagger) 문서화**     | API 명세를 자동화된 문서로 관리하여 변경사항을 실시간으로 공유 |
| **JSON Schema 기반 유효성 검사** | 요청/응답 데이터 구조를 검증하여 예외 상황을 사전에 방지 |
| **Contract Testing 도입**        | 프론트엔드와의 API 인터페이스 계약을 테스트 코드로 자동 검증 |
| **Feature Toggle / Beta API**    | 새로운 기능을 선택적으로 공개하여 실서비스에 영향 없이 검증 가능 |
| **하위 호환성 유지 원칙**        | 기존 기능이나 구조는 유지하며, 새 기능은 선택적으로 추가하여 안정성 확보 |

### 👀 핵심 요약
1. 공통 구조와 내부 에러 코드 체계를 통해 일관성 있는 응답을 가능하게 한다.
2. HTTP 상태 코드와 비즈니스 에러 코드를 병행하여 사용함으로써 클라이언트 디버깅 효율을 높인다.  
3. 정해진 네이밍 규칙과 RESTful한 URI 구조를 적용하여 유지보수의 용이성을 확보한다.  
4. URI 기반 버전 구분, Semantic Versioning, Deprecation 정책을 도입하여 변경 관리를 체계화한다.  
5. OpenAPI 기반 문서화, JSON Schema 유효성 검사, Contract Testing을 통해 신뢰도 높은 API를 운영한다.  
6. 기존 구조는 유지하며, 필드 추가 방식으로 확장해 하위 호환성을 보장한다.

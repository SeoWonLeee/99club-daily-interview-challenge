# 테스트 코드 작성 또는 TDD 경험
### 테스트 코드나 TDD 관점을 염두에 두고 개발 구조를 설계하거나 구현한 경험이 있다면 공유해 주세요. 꼭 완전한 테스트 주도 개발이 아니더라도, 테스트 가능성을 높이기 위해 고민했던 방식이 있다면 좋습니다.
힌트: 이 질문은 “TDD를 완벽하게 했는가”보다, 코드를 테스트하기 쉽게 만들기 위해 어떤 구조나 습관을 가졌는지를 보고자 합니다. 로직 분리, 의존성 주입, 인터페이스 추상화 같은 작은 실천도 강력한 답이 될 수 있습니다.
<br/> <br/>

### 🎯 테스트 코드 작성 경험
프로젝트에서 Location 기능은 사용자의 위치 정보를 기반으로 주변 사람을 탐색하거나, 위치를 등록/갱신/삭제하는 API를 제공하는 역할을 합니다.
위치 정보는 소셜 기능이나 사용자 간 매칭을 위한 핵심 데이터였기 때문에, 안정성과 테스트 가능성이 특히 중요했습니다.

이 기능을 개발하면서 완전한 TDD를 따르진 않았지만, 테스트 가능성을 높이기 위해 다음과 같은 설계를 실천했습니다:

1. **@WebMvcTest로 웹 계층 단위 테스트** : <br/> 
Location API는 REST 방식으로 구성되어 있어, 컨트롤러 단위에서 요청과 응답을 검증하기 위해 @WebMvcTest(LocationController.class)를 사용했습니다. 이를 통해 전체 애플리케이션이 아닌 웹 계층만 로드하여, 빠르고 명확한 테스트를 수행할 수 있었습니다.

2. **Mock 객체를 수동으로 주입하여 비즈니스 로직 분리** : <br/>
위치 등록/삭제/갱신과 같은 핵심 로직은 LocationService에 위임하고, 테스트에서는 이 서비스를 Mockito.mock()으로 대체하여, 컨트롤러 단위 테스트가 실제 구현에 의존하지 않도록 구성했습니다. 별도의 @TestConfiguration을 사용하여 Mock 객체를 빈으로 주입했습니다:
   ```java
   @TestConfiguration
   static class MockConfig {
       @Bean
       public LocationService locationService() {
           return LocationControllerTest.locationService;
       }
   }
   ```

3. **Spring Security 설정을 테스트에서 우회** : <br> 
해당 API는 인증된 사용자만 호출할 수 있기 때문에, 테스트에서는 @WithMockUser 어노테이션을 사용해 인증을 우회하고, CSRF 토큰을 명시적으로 포함시켜 실제 환경과 유사한 흐름을 재현했습니다.

4. **얇은 컨트롤러, 테스트 가능한 서비스 구조** : <br/> 
LocationController는 요청을 DTO로 받고, 모든 처리를 서비스에 위임하는 얇은 구조로 되어 있어 단위 테스트가 용이합니다. 실제 테스트에서는 JSON 요청과 응답을 직렬화/역직렬화하여 검증하며, HTTP 상태 코드 및 반환 데이터 검증도 함께 수행했습니다.
<br/>

### 배운점
Location 기능은 사용자 위치 기반의 매칭 및 소셜 기능에 중요한 역할을 하는 만큼, 다음과 같은 테스트 친화적인 구조로 개발했습니다:
- @WebMvcTest를 활용한 가벼운 계층 테스트
- Mock 객체 주입을 통한 외부 의존성 제거
- 인증/보안 설정을 고려한 현실적 테스트 구성
- 테스트를 염두에 둔 컨트롤러-서비스 책임 분리

이러한 구조는 테스트 자동화를 통한 안정성 확보뿐만 아니라, 변경에 강한 구조를 만드는 데도 도움이 되었습니다.
<br/> <br/>

---

## 🌱  테스트 코드 작성과 TDD(Test-Driven Development)
### 🥕 테스트 코드
테스트 코드는 개발자가 작성한 기능이 의도한 대로 동작하는지 자동으로 검증해주는 코드이다. 테스트를 통해 코드의 품질을 높이고, 리팩터링 시에도 안정적으로 변경할 수 있다.

### 🥕 TDD
TDD(Test-Driven Development)는 “테스트 주도 개발”이라고 하며, 아래와 같은 3단계 사이클을 반복하며 개발을 진행한다:
1. 실패하는 테스트 작성 (Red) : 기능 요구사항에 맞는 테스트 코드를 먼저 작성한다. 이 시점엔 테스트가 실패해야 정상이다.
2. 기능 구현 (Green) : 테스트가 통과하도록 최소한의 코드를 작성한다.
3. 리팩터링 (Refactor) : 테스트가 통과하는 상태를 유지하면서 코드 품질을 개선한다.
<br/>

### 🧑🏻‍🌾 테스트 코드를 잘 작성하기 위한 실천
1. 로직과 입출력 분리: 컨트롤러는 얇게 유지하고, 서비스와 도메인은 순수한 로직만 담당하도록 분리하는 것이 좋다.
2. 의존성 주입(DI): 의존성을 외부에서 주입받도록 설계하면 테스트 시 Mock이나 Fake 객체로 쉽게 대체할 수 있다.
3. 인터페이스 추상화: 외부 시스템(API, DB 등)과의 결합도를 낮추기 위해 인터페이스로 감싸는 것이 바람직하다.
4. 불변 객체 및 순수 함수 사용: 상태 변화가 없는 코드일수록 부작용이 없고, 테스트가 쉬워지므로 적극적으로 활용해야 한다.
<br/>

### 👀 핵심요약
1. 테스트 코드는 개발자가 작성한 기능이 의도한 대로 동작하는지 자동으로 검증해주는 코드이다.
2. TDD는 실패하는 테스트를 먼저 작성하고, 테스트를 통과시키는 최소한의 코드를 구현한 뒤, 이를 리팩터링하는 3단계 개발 사이클을 반복하는 방식이다.
3. 테스트 코드를 잘 작성하기 위해서는 로직과 입출력을 분리하고, 의존성은 외부에서 주입하며, 외부 시스템은 인터페이스로 추상화하고, 불변 객체 및 순수 함수를 활용하는 습관이 필요하다.
4. 이러한 실천은 테스트 자동화를 용이하게 하며, 코드의 품질과 유지보수성을 높이는 데 기여한다.
